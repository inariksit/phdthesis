\section{Case study: Fixing the Dutch grammar}
\label{dutch-experiment}

In this section, we describe the long-term project of fixing bugs in
the Dutch resource grammar. The content of the section describes
general principles, and is well understandable for readers who don't
speak Dutch themselves.


\subsection{Experimental setup}\label{experimental-setup}

We describe a collaboration between a grammarian (the author), who is an
expert in \gf, and a native Dutch speaker. We wanted to investigate the
feasibility of this division of labour: ideally, the tester can be any
native speaker, with no skills in \gf{} whatsoever. In our case, the tester
also had \gf{} skills, but did not have access to the grammar, only to the
produced sentences.

We generated a set of test sentences for each function in Dutch, with
English translations, and gave them to the native tester to read. The
tester replied with a list of sentences that were wrong, along with
suggestions for improvement. Communication between the grammarian and
the tester was conducted via email.


\subsection{Types of bugs}\label{types-of-bugs}

We can classify the bugs in two dimensions: how easy it is to understand
what the problem is, and how easy it is to fix the grammar. Ease of
understanding is relative to the grammarian: a trained linguist who is
fluent in Dutch would have easy time pinpointing the error from the
generated test cases, having both intuition and technical names for
things. Ease of fixing is relative to the grammar: a given grammatical
phenomenon can be implemented in a variety of ways, some of which are
harder to understand.

% Say that relative clauses are implemented as
% terrible spaghetti code in a Dutch grammar, but very elegantly in a
% German grammar, and both have a bug that results in a similar
% ungrammatical sentences. In such a case, the problem would be equally
% easy to understand in both languages, but fixing the bug could arguably
% be easier in one of the languages: in the language with neat abstractions,
% changing one line fixes that one bug and any similar ones. On
% in the German grammar. \todo{does it break more easily for german?}

In more concrete terms, \emph{easy to fix} means just some local changes
in a single function. In contrast, bugs that are \emph{hard to fix}
usually involve modifying several functions, restructuring the code or
adding new parameters.

\paragraph{Easy to understand, easy to
fix}\label{easy-to-understand-easy-to-fix}

Perhaps the easiest bug to fix is to correct a wrong lexical choice.
Below is an example feedback from the tester.

\begin{quote}
``opschakelen'' is not the right translation of ``switch on''.
``aanzetten'' or ``aandoen'' is better.
\end{quote}

Other examples include wrong inflection or agreement, e.g.~the polite
second person pronoun should take the third person singular verb form,
but was mistakenly taking second person forms.

Typically, bugs that are due to an almost complete implementation are
easy to fix. For instance, particle verbs were missing the particle in
future tense. Looking at the generated sentences, we could see the
particle being in the right place in all other tenses, except for the
future. There was a single function that constructed all the tenses, and
looking at the source code, we could see the line
\texttt{++ verb.particle} in all other tenses except the future. In such
a case, fixing the bug is fairly trivial.

\paragraph{Easy to understand, hard to
fix}\label{easy-to-understand-hard-to-fix}
Dutch negation uses two strategies: the clausal negation particle
\emph{niet} `not', and the noun phrase negation \emph{geen} `no'. There
are some subtleties in their usage---the following quote comes from the
tester:

\begin{quote}
In any case, one can never say ``eet niet wormen'' (don't eat worms,
literally).\\That should always be ``eet geen wormen'' (don't eat worms,
correctly translated)
\end{quote}

\noindent We sent three more sentences as follow-up, and got the
following answer:

\begin{quote}
eet niet deze wormen - maybe OK?, feels strange\\eet deze wormen niet -
definitely OK\\eet niet 5 wormen - definitely OK
\end{quote}

\noindent From the feedback, it was fairly easy to see the pattern:
clauses with indefinite noun phrases (\emph{a} worm, \emph{worms}) use
noun phrase negation, but if the noun phrase has any other determiner
(\emph{these} worms, \emph{five} worms), then clausal negation is
appropriate.

In the grammar, this fix required changes to 13 categories. Not all
categories had to be changed manually, but e.g.~a change in \texttt{NP}
changes all categories that depend on it, such as \texttt{Comp} and
\texttt{VP}. Depending on how modularly the grammar is implemented, this
means that some functions that operate on \texttt{VP} or \texttt{Comp}
need to be changed too, when \texttt{NP} changes.

\paragraph{Hard to understand, easy to fix}\label{hard-to-understand-easy-to-fix}

The following two sentences were generated by the same function, which
turns superlative adjectives and ordinal numbers into complements. The
tester reported problems with both of them, as follows:

\begin{quote}
ik wil roodst worden --\textgreater{} ik wil \textbf{het} roodst worden
(`I want to become reddest')\\ik wil \sout{tiend} worden
--\textgreater{} ik wil \textbf{tiende} worden (`I want to become
tenth')
\end{quote}

\noindent We gave some more sentences to the tester, and got the following
feedback:

\begin{quote}
ik wil linker worden --\textgreater{} ik wil \textbf{de} linker worden
(`I want to become left')\\ik wil 224e worden = OK (`I want to become
224th')
\end{quote}

This small example gave at least three different ways of using these
complements: for numerals, no article and -e at the end (\emph{tiende}
`tenth'); for superlative adjectives, the article \emph{het} and no -e
at the end of the adjective (\emph{het roodst} `the reddest'), and for
a class of adjectives like \emph{left} and \emph{right}, the article
\emph{de} (\emph{de linker} `the left one').

In addition, the grammar has a separate construction for combining a
numeral and a superlative adjective, e.g. ``tenth best''. Since the
tests were generated per function, the main tester didn't read those
sentences at the same time. After noticing the additional function, we
asked another informant how to say \emph{Nth best}, and got an
alternative construction \mbox{\emph{op~(N-1)~na~best}}. Eventually, we got an
answer that the strategy used for superlative adjectives, i.e.~with the
article \emph{het} and no -e in the number, is acceptable.

Once it was clear to the grammarian how to proceed, fixing the bug was
easy. There was already a parameter for the adjective form: attributive
in two forms (strong and weak) and one predicative, and the different
classes of adjectives corresponded to the abstract syntax of the \gf{}
Resource Grammar Library (RGL).
Thus it was easy to modify the predicative form in a different way for
different adjective types. Earlier, the predicative was just identical
to the other attributive form, but now the \texttt{AP} type actually
contains 3 different strings for superlatives: \emph{beste} and
\emph{best} for attributive and \emph{het best} for predicative.
Adjectives in positive or comparative don't get the article: \emph{good}
is just \emph{goede}, \emph{goed} and \emph{goed} (not \emph{*het
goed}).

If there hadn't been already a parameter for different adjective forms,
or if the classes of words with different behaviours hadn't corresponded
to the RGL categories, then this bug would have required more work to fix.

\paragraph{Hard to understand, hard to
fix}\label{hard-to-understand-hard-to-fix}

As an example of a problem that was hard to understand and hard to
fix, we take the agreement of a reflexive construction in conjunction
with a verbal complement. The example works as well for English, so
for the convenience of the reader, we use English as an example
language.  Now, consider the following sentences:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  I like myself / you like yourself / \ldots{}
\item
  I help [ you like yourself / them like themselves / \ldots{} ]
\end{itemize}

The choices of reflexive pronoun seem reasonable: if the object of liking was \emph{I}
in the second example, the pronoun wouldn't be \emph{myself} but \emph{me}: ``I
help you like me''.
In the \gf{} grammar, these sentences are constructed in a series of steps:
\begin{EmptyItem}
\begin{Highlighting}[]
\DataTypeTok{PredVP} \NormalTok{(}\DataTypeTok{UsePron} \NormalTok{i_Pron)}
       \NormalTok{(}\DataTypeTok{ComplSlash}
           \NormalTok{(}\DataTypeTok{SlashV2V} \NormalTok{help_V2V}
               \NormalTok{(}\DataTypeTok{ReflVP}
                 \NormalTok{(}\DataTypeTok{SlashV2a} \NormalTok{like_V2)}
               \NormalTok{)}
           \NormalTok{)}
           \NormalTok{(}\DataTypeTok{UsePron} \NormalTok{they_Pron)}
       \NormalTok{)}
\end{Highlighting}
\end{EmptyItem}

The innermost subtree is \texttt{SlashV2a like\_V2}: the transitive verb
\emph{like} is converted into a \texttt{VPSlash} (i.e.
\texttt{VP\textbackslash{}NP}). Right after, the function
\texttt{ReflVP} fills the \texttt{NP} slot and creates a \texttt{VP}.
However, no concrete string for the object is yet chosen, because the
reflexive object depends on the subject. The status of the VP is as
follows at the stage \texttt{ReflVP (SlashV2a like\_V2)}:

\begin{EmptyItem}
\begin{Highlighting}[]
    \NormalTok{s }\FunctionTok{=} \StringTok{"like"} \NormalTok{;}
\NormalTok{ncomp }\FunctionTok{=} \NormalTok{table \{ }\DataTypeTok{I} \OtherTok{=>} \StringTok{"myself"} \NormalTok{; }\DataTypeTok{You} \OtherTok{=>} \StringTok{"yourself"} \NormalTok{; â€¦ \} ;}
\NormalTok{vcomp }\FunctionTok{=} \NormalTok{[] ;}
\end{Highlighting}
\end{EmptyItem}

If we added a subject at that point, the subject would choose the
appropriate agreement: \emph{I} like \emph{myself}, \emph{you} like
\emph{yourself}. But instead, we add another slash-making construction,
\texttt{SlashV2V help\_V2V}. Now the new verb \texttt{help\_V2V}, which
takes both a direct object and a verbal complement, becomes the main
verb. The old verb \emph{like} becomes a verbal complement.

\begin{EmptyItem}
\begin{Highlighting}[]
    \NormalTok{s }\FunctionTok{=} \StringTok{"help"} \NormalTok{;}
\NormalTok{ncomp }\FunctionTok{=} \NormalTok{table \{ }\DataTypeTok{I} \OtherTok{=>} \StringTok{"myself"} \NormalTok{; }\DataTypeTok{You} \OtherTok{=>} \StringTok{"yourself"}\NormalTok{; â€¦ \} ;}
\NormalTok{vcomp }\FunctionTok{=} \StringTok{"like"} \NormalTok{;}
\end{Highlighting}
\end{EmptyItem}

The next stage is to add an \texttt{NP} complement \texttt{they\_Pron},
using the function \texttt{ComplSlash}. The standard way for
\texttt{ComplSlash} is to insert its \texttt{NP} argument into the
\texttt{ncomp} table, taking the \texttt{vcomp} field along.

In the old buggy version, \texttt{ComplSlash} just concatenated the new
object and the \texttt{vcomp} with the reflexive that was already in the
\texttt{ncomp} table. But the scope of the reflexive was wrong: when
adding an object to a \texttt{VPSlash} that has a verbal complement
clause, the object should complete the verbal complement and pick the
agreement. It is not in the scope for the subject.\\
The old behaviour was as follows:

\begin{EmptyItem}
\begin{Highlighting}[]
    \NormalTok{s }\FunctionTok{=} \StringTok{"help"} \NormalTok{;}
\NormalTok{ncomp }\FunctionTok{=} \NormalTok{table \{ }\DataTypeTok{I} \OtherTok{=>} \AlertTok{"them like myself"} \NormalTok{; }\DataTypeTok{You} \OtherTok{=>} \AlertTok{"them like yourself"}\NormalTok{; â€¦ \} ; }
\NormalTok{vcomp }\FunctionTok{=} \NormalTok{[] ;}
\end{Highlighting}
\end{EmptyItem}

After fixing the bug, the table was as follows:

\begin{EmptyItem}
\begin{Highlighting}[]
    \NormalTok{s }\FunctionTok{=} \StringTok{"help"} \NormalTok{;}
\NormalTok{ncomp }\FunctionTok{=} \NormalTok{table \{ _ }\OtherTok{=>} \StringTok{"them like themselves"} \NormalTok{\} ;}
\NormalTok{vcomp }\FunctionTok{=} \NormalTok{[] ;}
\end{Highlighting}
\end{EmptyItem}

But this turned out not to be a perfect solution. The exception to this
is when the \texttt{VPSlash} is formed by
\texttt{VPSlashPrep : VP -\textgreater{} Prep -\textgreater{} VPSlash}.
With the changes to \texttt{ComplSlash}, we suddenly got sentences such
as ``{[}I like \emph{ourselves}{]} without \emph{us}''. This would be a
valid linearisation for a tree where {[}\emph{ourselves} without
\emph{us}{]} is a constituent (such a tree is formed by another set of
functions and was linearised correctly), but in this case, the order of
the constructors is as follows:

\begin{itemize}
\item
  \t{ReflVP like}

\begin{EmptyItem}
\begin{Highlighting}[]
    \NormalTok{s }\FunctionTok{=} \StringTok{"like"} \NormalTok{;}
\NormalTok{ncomp }\FunctionTok{=} \NormalTok{table \{ }\DataTypeTok{I} \OtherTok{=>} \StringTok{"myself"} \NormalTok{; }\DataTypeTok{You} \OtherTok{=>} \StringTok{"yourself"} \NormalTok{; â€¦ \} ;}
\end{Highlighting}
\end{EmptyItem}

\item
  \t{VPSlashPrep (ReflVP like) without}

\begin{EmptyItem}
\begin{Highlighting}[]
    \NormalTok{s }\FunctionTok{=} \StringTok{"like"} \NormalTok{;}
\NormalTok{ncomp }\FunctionTok{=} \NormalTok{table \{ }\DataTypeTok{I} \OtherTok{=>} \StringTok{"myself"} \NormalTok{; }\DataTypeTok{You} \OtherTok{=>} \StringTok{"yourself"} \NormalTok{; â€¦ \} ;}
 \NormalTok{prep }\FunctionTok{=} \StringTok{"without"}
\end{Highlighting}
\end{EmptyItem}

\item \t{ComplSlash (VPSlashPrep (ReflVP like) without) we\_Pron)}

\begin{EmptyItem}
\begin{Highlighting}[]
    \NormalTok{s }\FunctionTok{=} \StringTok{"like"} \NormalTok{;}
\NormalTok{ncomp }\FunctionTok{=} \NormalTok{table \{ }\DataTypeTok{I} \OtherTok{=>} \StringTok{"myself"} \NormalTok{; }\DataTypeTok{You} \OtherTok{=>} \StringTok{"yourself"} \NormalTok{; â€¦ \} ;}
  \NormalTok{adv }\FunctionTok{=} \StringTok{"without us"}
\end{Highlighting}
\end{EmptyItem}

\end{itemize}

The desired behaviour is to put the complement into an adverbial slot
and keeping the agreement in \texttt{ncomp} open to wait for the
subject. But the following happened after our initial changes in
\texttt{ComplSlash}:

\begin{EmptyItem}
\begin{Highlighting}[]
    \NormalTok{s }\FunctionTok{=} \StringTok{"like"} \NormalTok{;}
\NormalTok{ncomp }\FunctionTok{=} \NormalTok{table \{ _ }\OtherTok{=>} \AlertTok{"ourselves without us"} \NormalTok{\} ; }
\end{Highlighting}
\end{EmptyItem}

To fix this problem, we added another parameter to the category
\texttt{VPSlash}. All \texttt{VPSlash}es constructed by
\texttt{VPSlashPrep} have now a \texttt{missingAdv} set True: this tells
that the \texttt{VPSlash} is not missing a core argument, so it
shouldn't affect the agreement. With the new parameter,
\texttt{ComplSlash} can now distinguish when to choose the agreement
from the \texttt{NP} argument and when to leave it open for the subject.

All in all, this was a complex phenomenon, and there were different
interpretations in the RGL. For the Scandinavian languages, the
behaviour was as we expected, but for English and German, it was
similar to Dutch. We fixed the grammar for all three languages (Dutch,
English and German), using the same strategy.

\subsection{Statistics}\label{numbers}

How many bugs were fixed and how many were of which kind? We skip the
ease of understanding, and just classify the bugs by how easy they were to fix.

\paragraph{Easy to fix}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Several lexical changes.
\item
  Several inflection fixes.
\item
  \t{youPol\_Pron} had agreement of \t{Sg P2}, changed it to \t{Sg P3} so that a
  correct reflexive pronoun is chosen.
\item
  Choose always stressed forms of personal pronouns.
\item
  Change agreement in conjunctions
\item
  Extra prefix in prefix verbs for perfect tense
\item
  Missing participle in future tense
\item
  Plural imperatives
\item Two bugs in postmodifier \texttt{AP}s: placement and the
  adjective form. \emph{een getrouwde worm} `a married worm' is
  correct, but a heavier \texttt{AP}, such as \emph{getrouwd met mij}
  `married with me' should become a postmodifier (\emph{een worm
    getrouwd met mij}), and in that case, the adjective form should be
  without the e at the end.
\item
  Superlatives and ordinals
\item \t{DetQuant} (and \t{DetQuantOrd}) combining a \t{Quant} and a
  \t{Num}, and when \t{Num} is an actual digit, both \t{Quant} and the \t{Num}
  contribute with a string, thus becoming \emph{een 1 huis} `a 1
  house'.
\end{enumerate}

\paragraph{Hard to fix}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Add missing inflected forms for past participles + add missing
  linearisation for the function \texttt{PastPartAP}
\item
  Preposition contraction (\emph{met dit huis} `with this house' and
  \emph{hiermee} `with this')
\item
  Negation patterns (\emph{niet} and \emph{geen})
\item
  Variety of word order weirdness in verbal complements: affected
  several functions, fixed in several functions
\item
  Scope of \texttt{ReflVP} with \texttt{VPSlash}
\end{enumerate}

\paragraph{Effort}

Tester 1 has read around 5,000 sentences over the course of several
weeks, usually taking just minutes of time at one go. Tester 2 has
been used as a backup when Tester 1 was not available and the
grammarian wanted quick feedback. Where Tester 1 was instructed to
read through a long list of sentences (out of which most are correct),
Tester 2 has been given sentences that Tester 1 already flagged as
wrong. All in all, Tester 2 has read around 50 sentences.

We found that communication via email was suboptimal, and would be
hard to scale up to more testers.  In the future, we aim to improve
the process management with a more efficient workbench.
