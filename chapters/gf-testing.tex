\chapter{Test Case Generation for Grammatical Framework}
\label{chapterGFtest}

Traditionally, GF grammars are tested by the grammarians themselves,
much like unit testing. % in traditional software development.
When implementing some feature, such as relative clauses, the grammarian
comes up with a test suite of sentences that include relative clauses, 
and stores in the form of abstract syntax trees. In principle, a test suite created for one
language can easily be reused for another, because the ASTs are identical.
Ideally, every time someone touches relative clauses in the any concrete syntax, the trees 
in the test suite will be linearized with the changed concrete syntax, and verified by 
someone who speaks the language (or compared to the original gold standard, if there is one).
This scheme can fail for various reasons:

\begin{itemize}
\item The original list is not exhaustive: for instance, it tests only ``X, who loves me'' but not ``X, whom I love''.
\item The original list is exhaustive in one language, but not in all: for instance, it started in English and only included one noun, but in French it would need at least one masculine and one feminine noun.
\item The list is overly long, with redundant test cases, and human testers are not motivated to read through.
\item A grammarian makes a change somewhere else in the grammar, and does not realize that it affects relative clauses, and thus does not rerun the appropriate test suite.
\end{itemize}

We are working on a system that addresses these questions, with a working implementation on GitHub\footnote{\texttt{\small \url{ https://github.com/inariksit/GF-testing}}}. 
Our preliminary version is already usable for real, large-scale grammar development, and we have found errors in the grammars we have tested, for languages such as Dutch and Hindi.
The biggest downside to automatically generated test sentences is the lack of semantic coherence---we expect nonsensical sentences to be more easily judged as grammatically incorrect, especially by oracles who are not language professionals.

We plan to look into existing text corpora, and find trees that are structurally identical  to those that our program generates as a minimal and representative example. As a simplified example, ``a worm without winter'', generated by the program, would be identical\footnote{This particular example holds for English, but in another language, the words ``pizza'' and ``worm'', as well as ``winter'' and ``cheese'' may not match in all relevant features---grammatical gender, whether the word starts with a vowel or a consonant, etc. All this information comes from the concrete syntax!}
 in structure to ``a pizza without cheese'', found in a real text, and can thus be substituted for the generated one.  
Alternatively, we could use statistical information on co-occurrences of words, and generate appropriate pools of words, from which we draw example sentences.